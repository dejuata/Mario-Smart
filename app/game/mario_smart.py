#!/usr/bin/python
# -*- coding: utf-8 -*-

# Basado en https://www.cs.us.es/cursos/iati-2012/

class MarioSmart(object):

  def __init__(self, initial, goal=None):
    self.initial = initial
    self.goal = goal

  def actions(self, state):
    """
    Return the actions that can be executed in the given state
    """
    pass

  def result_of_actions(self, state, action):
    """
    Return the state that results from executing the in the given state
    """
    pass

  def goal_test(self, state):
    """
    Return True if the state is a goal
    """
    return state == self.goal

  def path_cost(self, c, state1, action, state2):
    """
    Return the cost of a solution path that arrives at state2 from
    state1 via action, assuming cost c to get up to state1.
    """
    return c + 1


class Node:
  """
  Un nodo se define como:
  • El estado del problema
  • Una referencia al nodo padre
  • El operador que se aplicó para generar el nodo
  • Profundidad del nodo
  • El costo de la ruta desde la raíz hasta el nodo
  """

  def __init__(self, state, parent=None, action=None, path_cost=0):
    self.state = state
    self.parent = parent
    self.action = action
    self.path_cost = path_cost
    self.depth = 0
    if parent:
      self.depth = parent.depth + 1

  def __repr__(self):
    return "<Nodo {}>".format(self.state)

  def __lt__(self, node):
    return self.state < node.state

  def expand(self, problem):
    """
    List of nodes generated by the possible actions applied to the initial state
    """
    return [self.child_node(problem, action) for action in problem.actions(self.state)]

  def child_node(self, problem, action):
    """
    Successor of a node by an applicable action
    """
    next_node = problem.result(self.state, action)
    return Node(
      next_node,
      self,
      action,
      problem.path_cost(self.path_cost, self.state, action, next_node)
    )

  def solution(self):
    """
    Return the sequence of actions to go from the root to this node.
    """
    return [node.action for node in self.path()[1:]]

  def path(self):
    """
    Return a list of nodes forming the path from the root to this node.
    """
    node, path_back = self, []
    while node:
        path_back.append(node)
        node = node.parent
    return list(reversed(path_back))

  def __eq__(self, other):
    return isinstance(other, Node) and self.state == other.state

  def __hash__(self):
    return hash(self.state)


